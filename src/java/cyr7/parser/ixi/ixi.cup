/*
   Simple +/-/* expression language; 
   parser evaluates constant expressions on the fly
*/

package cyr7.parser.ixi;

import java_cup.runtime.*;
import cyr7.ast.*;
import java.util.List;
import java.util.LinkedList;

parser code {:
:};

action code {:
:}

/* define how to connect to the scanner! */
init with {:
:};

scan with {: 
	Symbol sym = getScanner().next_token();
 	return (sym != null) ? sym : getSymbolFactory().newSymbol("END_OF_FILE",EOF_sym()); 
:};

/* Terminals (tokens returned by the scanner). */


// Punctuation
terminal L_PAREN, R_PAREN, L_SQ_BRKT, R_SQ_BRKT;
terminal COLON, SEMICOLON, COMMA;

// types
terminal TYPE_INT, TYPE_BOOL;

// misc
terminal String ID;

// Program-wide
nonterminal IxiProgramNode program;
nonterminal List<FunctionDeclNode> FunctionDeclList;
nonterminal FunctionDeclNode Statement;
nonterminal FunctionDeclNode FunctionDecl;
nonterminal StatementEnd;

nonterminal List<FunctionArgNode> Arg;
nonterminal List<FunctionArgNode> Arglist;

nonterminal List<TypeNode> ReturnType;
nonterminal List<TypeNode> ReturnTypeList;

nonterminal TypeNode Type;
nonterminal PrimitiveTypeNode Primitive;

start with program;

program ::= FunctionDeclList:lst {: RESULT = new IxiProgramNode(lst); :};
FunctionDeclList ::= FunctionDeclList:lst Statement:stmt {: 
			lst.add(stmt);
			RESULT = lst;
		:}
					| {: RESULT = new LinkedList<>(); :}
					;
Statement ::= FunctionDecl:decl StatementEnd {:
			RESULT = decl;
		:};

FunctionDecl ::= ID:id L_PAREN Arg:argList R_PAREN ReturnType:returnList {:
			RESULT = new FunctionDeclNode(id, argList, returnList);
		:};

StatementEnd ::= SEMICOLON
				| 
				;
Arg ::= ID:id COLON Type:t Arglist:lst {: 
			lst.add(new FunctionArgNode(id, t));
			RESULT = lst;
		:}
		| {: RESULT = new LinkedList<>(); :}
		;
		
Arglist ::= COMMA ID:id COLON Type:t Arglist:lst {: 			
				lst.add(new FunctionArgNode(id, t));
				RESULT = lst; 
			:}
			| {: RESULT = new LinkedList<>(); :}
		  	;

ReturnType ::= COLON Type:t ReturnTypeList:lst {: lst.add(t); RESULT = lst; :}
			|	{: RESULT = new LinkedList<>(); :} 
			;

ReturnTypeList ::= ReturnTypeList:lst COMMA Type:t {: lst.add(t); RESULT = lst; :}
				| {: RESULT = new LinkedList<>(); :}
				;

Type ::= Type:t L_SQ_BRKT R_SQ_BRKT {: RESULT = new ArrayTypeNode(t); :}
		| TYPE_INT {: RESULT = new PrimitiveTypeNode(PrimitiveEnum.INT); :} 
		| TYPE_BOOL {: RESULT = new PrimitiveTypeNode(PrimitiveEnum.BOOL); :};

/* The grammar rules */
/*
expr_list ::= expr_list expr:e SEMI         {: System.out.println(e); :}
            | expr:e SEMI                   {: System.out.println(e); :}
            ;
            
expr      ::= expr:e1 PLUS  expr:e2         {: RESULT = e1+e2;        :}
             | expr:e1 MINUS expr:e2        {: RESULT = e1-e2;        :}
             | expr:e1 TIMES expr:e2        {: RESULT = e1*e2;        :}
             | MINUS expr:e                 {: RESULT = -e;           :}
             %prec UMINUS
             | LPAREN expr:e RPAREN	         {: RESULT = e;           :}
             | NUMBER:n	                     {: RESULT = n;           :}
             ;
*/