/*
   Simple +/-/* expression language; 
   parser evaluates constant expressions on the fly
*/

package cyr7.parser;

import java_cup.runtime.*;
import cyr7.ast.*;
import java.util.LinkedList;

parser code {:
:};

action code {:
:}

/* define how to connect to the scanner! */
init with {:
:};

scan with {: 
	Symbol sym = getScanner().next_token();
 	return (sym != null) ? sym : getSymbolFactory().newSymbol("END_OF_FILE",EOF_sym()); 
:};

/* Terminals (tokens returned by the scanner). */


terminal IXI_FILE, XI_FILE;
// Punctuation
terminal IF, ELSE, RETURN, USE, WHILE, LENGTH;

// Identifier
terminal String ID;

// Types
terminal String TYPE_INT, TYPE_BOOL;

// Values
terminal Long INT_LITERAL;
terminal String STRING_LITERAL;
terminal Character CHAR_LITERAL;
terminal Boolean BOOL_LITERAL;

// Punctuation
terminal L_PAREN, R_PAREN, L_SQ_BRKT, R_SQ_BRKT, L_BRACE, R_BRACE;
terminal COLON, SEMICOLON, COMMA, UNDERSCORE;

// Operators
terminal ASSIGN,
         PLUS,
         MINUS,
         MULT,
         HIGH_MULT,
         DIVIDE,
         EQUALS,
         NOT_EQUALS,
         LT,
         LTE,
         GT,
         GTE,
         NEG_BOOL,
         REMAINDER,
         LOGICAL_AND,
         LOGICAL_OR;

// Program-wide
nonterminal ProgramNode program;
nonterminal IxiProgramNode ixi_program;
nonterminal LinkedList<FunctionDeclNode> FunctionDeclList;
nonterminal FunctionDeclNode Statement;
nonterminal FunctionDeclNode FunctionDecl;
nonterminal StatementEnd;

nonterminal LinkedList<FunctionArgNode> Arg;
nonterminal LinkedList<FunctionArgNode> Arglist;

nonterminal LinkedList<TypeNode> ReturnType;
nonterminal LinkedList<TypeNode> ReturnTypeList;

nonterminal TypeNode Type;
nonterminal PrimitiveTypeNode Primitive;

start with program;

program ::= IXI_FILE ixi_program:ixi {: RESULT = ixi; :}; 
ixi_program ::= FunctionDeclList:lst {: RESULT = new IxiProgramNode(lst); :};
FunctionDeclList ::= FunctionDeclList:lst Statement:stmt {: 
			lst.addLast(stmt);
			RESULT = lst;
		:}
					| {: RESULT = new LinkedList<>(); :}
					;
Statement ::= FunctionDecl:decl StatementEnd {:
			RESULT = decl;
		:};

FunctionDecl ::= ID:id L_PAREN Arg:argList R_PAREN ReturnType:returnList {:
			RESULT = new FunctionDeclNode(id, argList, returnList);
		:};

StatementEnd ::= SEMICOLON
				| 
				;
Arg ::= ID:id COLON Type:t Arglist:lst {: 
			lst.addFirst(new FunctionArgNode(id, t));
			RESULT = lst;
		:}
		| {: RESULT = new LinkedList<>(); :}
		;
		
Arglist ::= COMMA ID:id COLON Type:t Arglist:lst {: 			
				lst.addFirst(new FunctionArgNode(id, t));
				RESULT = lst; 
			:}
			| {: RESULT = new LinkedList<>(); :}
		  	;

ReturnType ::= COLON Type:t ReturnTypeList:lst {: lst.addFirst(t); RESULT = lst; :}
			|	{: RESULT = new LinkedList<>(); :} 
			;

ReturnTypeList ::= ReturnTypeList:lst COMMA Type:t {: lst.addLast(t); RESULT = lst; :}
				| {: RESULT = new LinkedList<>(); :}
				;

Type ::= Type:t L_SQ_BRKT R_SQ_BRKT {: RESULT = new ArrayTypeNode(t); :}
		| TYPE_INT {: RESULT = new PrimitiveTypeNode(PrimitiveEnum.INT); :} 
		| TYPE_BOOL {: RESULT = new PrimitiveTypeNode(PrimitiveEnum.BOOL); :};

/* The grammar rules */
/*
expr_list ::= expr_list expr:e SEMI         {: System.out.println(e); :}
            | expr:e SEMI                   {: System.out.println(e); :}
            ;
            
expr      ::= expr:e1 PLUS  expr:e2         {: RESULT = e1+e2;        :}
             | expr:e1 MINUS expr:e2        {: RESULT = e1-e2;        :}
             | expr:e1 TIMES expr:e2        {: RESULT = e1*e2;        :}
             | MINUS expr:e                 {: RESULT = -e;           :}
             %prec UMINUS
             | LPAREN expr:e RPAREN	         {: RESULT = e;           :}
             | NUMBER:n	                     {: RESULT = n;           :}
             ;
*/